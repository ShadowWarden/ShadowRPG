/* kardinal/state.c
*  Omkar H. Ramachandran
*  omkar.ramachandran@colorado.edu
*
*  Main script parser/logic interface of the game. Do not edit this file unless 
*  absolutely necessary
* 
*
*  This project is under the GNU General GPL version 3.0 license. For more 
*  information about the license, refer the LICENCE file in the root directory 
*  or go online to <http://www.gnu.org/licenses>
*  
*  Any redistribution of this code must contain this header in its entirety
*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "kardinal.h"

int Statecpy(State *a, State b){
	a->id = b.id;
	strcpy(a->name,b.name);
	a->attribute=b.attribute;
}

int getsize(FILE * in){
	int N;
	fseek(in,SEEK_SET,0);
	fscanf(in,"size=%d",&N);
	return N;
}

int build_states_test(FILE * in, int debug){
/*
*
*
*/
	(debug==1) ? fprintf(stderr,"(build_states_test) Debug : Entered build_states_test\n") : 0;
	TitleSize = getsize(in);	
	(debug==1) ? fprintf(stderr,"(build_states_test) Debug : Survived getsize\n") : 0;	
	Titles = (State *) malloc (sizeof(State)*TitleSize);
	(debug==1) ? fprintf(stderr,"(build_states_test) Debug : Malloced Titles\n") : 0;
	int i=0;

	for(i=0;i<TitleSize;i++){
		int att;
		char name[20];
		fscanf(in,"%s %d",name,&att);
		strcpy(Titles[i].name,name);
		Titles[i].attribute = att;
		Titles[i].id = i+1;
	}
}

int find_ttl(int StateId, State ** Player, int * PlayerSize, int debug){
	int i,flag=0;
	for(i=0;i<*PlayerSize;i++){
		if(StateId == ((*Player)+i)->id){
			(debug==1) ? fprintf(stderr,"(find_ttl) Debug : State %d found at i=%d\n",StateId,i) : 0;
			flag++;
			break;
		}
	}
	if(flag == 0){
		// State not Found
		(debug==1) ? fprintf(stderr,"(find_ttl) Debug : State %d not found\n",StateId) : 0;
		return -1; 
	}else{
		return 0;
	}
}

int add_state_to_player(int StateId, State ** Player, int *PlayerSize, int debug){
/* Assume sorted, do insertion sort of 1 element to keep the array sorted
*  Error checks need to be done. Check max stateid and so on
*/
	int i,j;
	if(*PlayerSize>0){
		(*Player) = (State *) realloc((*Player),sizeof(State)*(*PlayerSize+1)); 
	}else{
		(*Player) = (State *) malloc(sizeof(State)*(*PlayerSize+1)); 
	}
	*PlayerSize+=1;
	(debug==1) ? fprintf(stderr,"(add_state_to_player) Debug : PlayerSize = %d\n",*PlayerSize) : 0;
	for(i=0;i<*PlayerSize;i++){
		(debug==1) ? fprintf(stderr,"(add_state_to_player) Debug : Player[%d].id = %d\n",i,((*Player)+i)->id) : 0;
		if(((*Player)+i)->id>=StateId || (*PlayerSize==1 && i==0) || i==*PlayerSize-1){
			for(j=*PlayerSize-1;j>i;j--){
				Statecpy((*Player)+j,*((*Player)+j-1));
			}
			Statecpy((*Player)+i,Titles[StateId-1]);
			break;
		}
	}
	return 0;
}

int remove_state_from_player(int StateId, State ** Player, int *PlayerSize, int debug){
/* Assume sorted, do insertion sort of 1 element to keep the array sorted
*  Error checks need to be done. Check max stateid and so on
*/
	int i,j;
	//int flag = 0;	

	(debug==1) ? fprintf(stderr,"(remove_state_from_player) Debug : PlayerSize = %d\n",*PlayerSize) : 0;
	for(i=0;i<*PlayerSize;i++){
		(debug==1) ? fprintf(stderr,"(remove_state_from_player) Debug : Player[%d].id = %d\n",i,((*Player)+i)->id) : 0;
		if((*Player)[i].id == StateId){
			for(j=i;j<*PlayerSize;j++){
				Statecpy((*Player)+j,*((*Player)+j+1));
			}
			break;
		}
	}
	*PlayerSize -= 1;
	if(*PlayerSize>0){
		(*Player) = (State *) realloc((*Player),sizeof(State)*(*PlayerSize)); 
	}else{
		free(*Player);
	}
// Very very IMPORTANT. Come up with a way by which we can avoid a double free
// here. If PlayerSize is indeed zero, we need to free player here and avoid
// an overlap in main	
	return 0;
}

int dump_states_test(int debug){
	int i=0;
	(debug==1) ? fprintf(stderr,"(dump_states_test) Debug : Dump of global states\n") : 0;
	(debug==1) ? fprintf(stderr,"(dump_states_test) Debug : TitleSize=%d\n",TitleSize) : 0;
	for(i=0;i<TitleSize;i++){
		(debug==1) ? fprintf(stderr,"(dump_states_test) Debug : %d %s %d\n",Titles[i].id,Titles[i].name,Titles[i].attribute) : 0;
	}
	printf("\n");
	return 0;
}

int print_player_state(State* P, int PlayerSize, int debug){
	int i;
	(debug==1) ? fprintf(stderr,"(print_player_states) Debug : Printing current Player state array\n") : 0;
	for(i=0;i<PlayerSize;i++){	
		printf("Debug : %d %s %d\n",P[i].id,P[i].name,P[i].attribute);
	}
	(debug==1) ? fprintf(stderr,"(print_player_states) Debug : Exiting print_player_state\n") : 0;
}
