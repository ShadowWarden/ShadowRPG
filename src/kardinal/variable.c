/* kardinal/variable.c
*  Omkar H. Ramachandran
*  omkar.ramachandran@colorado.edu
*
*  Main script parser/logic interface of the game. Do not edit this file unless 
*  absolutely necessary
* 
*
*  This project is under the GNU General GPL version 3.0 license. For more 
*  information about the license, refer the LICENCE file in the root directory 
*  or go online to <http://www.gnu.org/licenses>
*  
*  Any redistribution of this code must contain this header in its entirety
*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "kardinal.h"

int Free_var(VariableDec * Vars){
	while(Vars!=NULL){
		free(Vars->value);
		VariableDec * tmp = Vars;
		Vars = Vars->prev;
		free(tmp);
	}
	free(Vars);
}

void print_variable_stack(VariableDec Vars){
	VariableDec * tmp = &Vars;
	fprintf(stderr,"Debug : Printing current variable stack\n");
	while(tmp!=NULL){
		printf("Debug : %s : %s : %s : %d\n",tmp->varname,tmp->type,tmp->value,tmp->size);
		tmp=tmp->prev;
	}
	printf("\n");
}


/* This is STRICTLY a work in progress function! The return type is Input * 
*  because I didn't want to pass a pointer by reference (and thus work with
*  a pointer to a pointer which is also a struct).
*  If ANYONE has a better implementation, please implement it and send a 
*  pull request to VariableSupportOHR
*/
int setvar(VariableDec ** Vars, int * size_var, Input ** args){
	VariableDec *var = (VariableDec*)malloc(sizeof(VariableDec));
	if(var == NULL){
		fprintf(stderr,"Error : Malloc returned NULL. Is there any memory left?\n");
		return -1;
	}
	fprintf(stderr,"Debug : New Variable Allocated\n");
	if(*size_var == 0){
		var->prev=NULL;
	}else{
		var->prev=*Vars;
	}
	*Vars=var;
	*size_var+=1;
	//Extract Args here
	strcpy(var->type,(*args)->name);
	(*args)=(*args)->prev;
	
	if(strcmp(var->type,"string")==0){
		var->value=(char *)malloc(sizeof(char)*(strlen((*args)->name)+1));
		var->size=sizeof(char)*(strlen((*args)->name)+1);
	}else{
		var->value=NULL;
		var->size=0;
		fprintf(stderr,"Type not mentioned. Check documentation for syntax\n");
		return -2;
/*
*  NearlyHeadless,
*  Someone needs to do an errorcheck on the default. Ideally,
*  we just shouldn't allow the type variable to be empty
*/
	}
	if(strcmp(var->type,"string")==0){
		fprintf(stderr,"Debug : Assigning %s to var->value\n",(*args)->name);
		strcpy(var->value,(*args)->name);
		(*args) = (*args)->prev;
	}
	strcpy(var->varname,(*args)->name);
	
	return 0;
}
