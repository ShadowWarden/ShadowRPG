/* kardinal/variable.c
 * Omkar H. Ramachandran
 * omkar.ramachandran@colorado.edu
 *
 * Main script parser/logic interface of the game. Do not edit this file unless 
 * absolutely necessary
 * 
 *
 * This project is under the GNU General GPL version 3.0 license. For more 
 * information about the license, refer the LICENCE file in the root directory 
 * or go online to <http://www.gnu.org/licenses>
 *  
 * Any redistribution of this code must contain this header in its entirety
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "kardinal.h"
#include <ctype.h>

int Free_var(SymTable S){
		int i;
		for(i=0;i<CAP;i++){
				if(S.Vars[i]!=NULL){
						VariableDec * var = S.Vars[i];
						while(var != NULL){
								VariableDec *tmp = var;
								var = var->prev;
								free(tmp->value);
								free(tmp);
						}
				}
		}
		return 0;
}

/* void print_variable_stack(SymTable S){
 *		int i;
 *		for(i=0;i<CAP;i++){
 *				if(S.Vars[i]!=NULL){
 *						VariableDec * tmp = S.Vars[i];
 *						while(tmp != NULL){
 *								printf("%d:%c:%s:%d\n",i,tmp->varname,tmp->type,(int)*tmp->value,tmp->size);
 *								tmp = tmp->prev;
 *						}
 *				}
 *		}
 * }
 */

/* This is STRICTLY a work in progress function! The return type is Input * 
 *  because I didn't want to pass a pointer by reference (and thus work with
 *  a pointer to a pointer which is also a struct).
 *  If ANYONE has a better implementation, please implement it and send a 
 *  pull request to VariableSupportOHR
 */
int setvar(SymTable * S, Input ** args, int debug){
		VariableDec *var = (VariableDec*)malloc(sizeof(VariableDec));
		if(var == NULL){
				(debug==1) ? fprintf(stderr,"Error : Malloc returned NULL. Is there any memory left?\n") : 0;
				return -1;
		}
		(debug==1) ? fprintf(stderr,"Debug : New Variable Allocated\n") : 0;

		if((*args)->name[0]=='"'){
				/* If the first character is a ", then the type is string */		
		//		fprintf(stderr, "Debug: Variable is a string\n");
				var->type='s';
		}else if(isdigit((*args)->name[0])){
			int flag = 0;
			int j = 1;
			for(j=0;j<strlen((*args)->name);j++){
					if(isdigit((*args)->name[j])==0){
							flag = 1;
							break;	
					}
			}
			if(flag){
				free(var);
				fprintf(stdout,"Error in setvar: Unidentified type\n");
				return -2;
			}else{
				var->type = 'i';
			}
		}
		(debug==1) ? fprintf(stderr,"Debug : Type = %c\n",var->type) : 0;

		//Extract Args here
		if(var->type == 'i'){
				var->value=(char *)malloc(sizeof(int));
				//		var->size=sizeof(char)*(strlen((*args)->name)+1);
		}else if(var->type == 's'){
				var->value=(char *)malloc(sizeof(char)*(strlen((*args)->name)-2));
		}else{
				free(var);
				(debug==1) ? fprintf(stderr,"Type not mentioned. Check documentation for syntax\n") : 0;
				return -2;
				/*
				 *  NearlyHeadless,
				 *  Someone needs to do an errorcheck on the default. Ideally,
				 *  we just shouldn't allow the type variable to be empty
				 */
		}	// Compatible only for single float values
		if(var->type == 'i'){
				int intermediate_buffer = atoi((*args)->name);
				*var->value = intermediate_buffer;
				(debug==1) ? fprintf(stderr,"Debug: Assigned %d successfully\n",(int)*var->value) : 0;
		}else if(var->type == 's'){
				int j;
				for(j=1; j<strlen((*args)->name)-1; j++){
						if((*args)->name[j]=='\\'){
								var->value[j-1]='\n';
								j++;
						}else
								var->value[j-1]=(*args)->name[j];
				}
				var->value[j-1] = '\0';
				(debug==1) ? fprintf(stderr,"Debug: Assigned %s successfully\n",var->value) : 0;
		}

		(*args) = (*args)->prev;

		strcpy(var->varname,(*args)->name);
		int hashkey = createhash(var->varname);
		if(S->Vars[hashkey] == NULL){	
				S->Vars[hashkey]=var;
		}else{
				VariableDec * tmp = S->Vars[hashkey];
				while(tmp->prev != NULL){
						tmp = tmp->prev;
				}
				tmp->prev = var;
		}
		return 0;
}

int createhash(char * a){
		/* Simple hashing function
		 * For each letter, do
		 * 	sum += ascii(a[i]) + prime offset
		 *
		 */
		int i;
		int len = strlen(a);
		int sum = 0;
		for(i=0;i<len;i++){
				sum += (int) a[i] + OFFSET;
		}
		return sum%CAP;
}

int find_in_hash(VariableDec ** Found, SymTable S, char * varname){
		int hashkey = createhash(varname);
		VariableDec * vars =  S.Vars[hashkey];
		while(vars!=NULL){
				if(strcmp(vars->varname,varname) == 0){
					*Found = vars;		
					return 0;
				}else{
					vars = vars->prev;
				}
		}
		/* If it didn't return in the loop, then things went wrong */
		return 101;
}
