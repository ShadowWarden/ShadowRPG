/* kardinal/variable.c
 * Omkar H. Ramachandran
 * omkar.ramachandran@colorado.edu
 *
 * Main script parser/logic interface of the game. Do not edit this file unless 
 * absolutely necessary
 * 
 *
 * This project is under the GNU General GPL version 3.0 license. For more 
 * information about the license, refer the LICENCE file in the root directory 
 * or go online to <http://www.gnu.org/licenses>
 *  
 * Any redistribution of this code must contain this header in its entirety
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "kardinal.h"
#include <ctype.h>

int Free_var(SymTable S){
		int i;
		for(i=0;i<CAP;i++){
				if(S.Vars[i]!=NULL){
						VariableDec * var = S.Vars[i];
						while(var != NULL){
								VariableDec *tmp = var;
								var = var->prev;
								free(tmp->value);
								free(tmp);
						}
				}
		}
		return 0;
}

/* void print_variable_stack(SymTable S){
 *		int i;
 *		for(i=0;i<CAP;i++){
 *				if(S.Vars[i]!=NULL){
 *						VariableDec * tmp = S.Vars[i];
 *						while(tmp != NULL){
 *								printf("%d:%c:%s:%d\n",i,tmp->varname,tmp->type,(int)*tmp->value,tmp->size);
 *								tmp = tmp->prev;
 *						}
 *				}
 *		}
 * }
 */

/* This is STRICTLY a work in progress function! The return type is Input * 
 *  because I didn't want to pass a pointer by reference (and thus work with
 *  a pointer to a pointer which is also a struct).
 *  If ANYONE has a better implementation, please implement it and send a 
 *  pull request to VariableSupportOHR
 */
int setvar(SymTable * S, Input ** args, int debug){
		VariableDec *var = (VariableDec*)malloc(sizeof(VariableDec));
		int is_var=0;
		
		if(var == NULL){
				(debug==1) ? fprintf(stderr,"Error : Malloc returned NULL. Is there any memory left?\n") : 0;
				return -1;
		}
		(debug==1) ? fprintf(stderr,"Debug : New Variable Allocated\n") : 0;

		if((*args)->name[0]=='"'){
				/* If the first character is a ", then the type is string */		
		//		fprintf(stderr, "Debug: Variable is a string\n");
				var->type='s';
		}else if(isdigit((*args)->name[0])){
			int flag = 0;
			int j = 1;
			for(j=0;j<strlen((*args)->name);j++){
					if(isdigit((*args)->name[j])==0){
							flag = 1;
							break;	
					}
			}
			if(flag){
				free(var);
				fprintf(stdout,"Error in setvar: Unidentified type\n");
				return -2;
			}else{
				var->type = 'i';
			}
		}else{
			/* Argument is a variablename */
			VariableDec * tmp;
			int res = find_in_hash(&tmp,*S,(*args)->name);
			if(res != 0){
			// Something went wrong. Likely, the variable hasn't
			// been allocated yet	
				free(var);
				fprintf(stdout,"Error in setvar: Unknown symbol %s",(*args)->name);
				return res;
			}
			else{
				is_var = 1;	
				var->value = (char *) malloc(sizeof(tmp->value));
				*var->value = *tmp->value; 
				var->type = tmp->type;
			}
		}
		(debug==1) ? fprintf(stderr,"Debug : Type = %c\n",var->type) : 0;

		//Extract Args here
		if(!is_var){
			if(var->type == 'i'){
				var->value=(char *)malloc(sizeof(int));
				//		var->size=sizeof(char)*(strlen((*args)->name)+1);
			}else if(var->type == 's'){
				var->value=(char *)malloc(sizeof(char)*(strlen((*args)->name)-2));
			}else{
				free(var);
				(debug==1) ? fprintf(stderr,"Type not mentioned. Check documentation for syntax\n") : 0;
				return -2;
				/*
				 *  NearlyHeadless,
				 *  Someone needs to do an errorcheck on the default. Ideally,
				 *  we just shouldn't allow the type variable to be empty
				 */
			}	// Compatible only for single float values
			if(var->type == 'i'){
				int intermediate_buffer = atoi((*args)->name);
				*var->value = intermediate_buffer;
				(debug==1) ? fprintf(stderr,"Debug: Assigned %d successfully\n",(int)*var->value) : 0;
			}else if(var->type == 's'){
				int j;
				for(j=1; j<strlen((*args)->name)-1; j++){
						if((*args)->name[j]=='\\'){
								var->value[j-1]='\n';
								j++;
						}else
								var->value[j-1]=(*args)->name[j];
				}
				var->value[j-1] = '\0';
				(debug==1) ? fprintf(stderr,"Debug: Assigned %s successfully\n",var->value) : 0;
			}
		}
		(*args) = (*args)->prev;

		strcpy(var->varname,(*args)->name);
		var->prev = NULL;

		VariableDec *tmp_var;
		int res = find_in_hash(&tmp_var,*S,var->varname);

		if(res){
			int hashkey = createhash(var->varname);
			if(S->Vars[hashkey] == NULL){	
				S->Vars[hashkey]=var;
			}else{
				VariableDec * tmp = S->Vars[hashkey];
				while(tmp->prev != NULL){
						tmp = tmp->prev;
				}
				tmp->prev = var;
			}
		}else{
			/* Variable already in SymTable */
			free(tmp_var->value);
			tmp_var->value = (char *) malloc (sizeof(*var->value));
			if(var->type == 's')
				strcpy(tmp_var->value,var->value);
			else
				*tmp_var->value = *var->value;

			tmp_var->type = var->type;	
			free(var);
		}
			
		return 0;
}

int createhash(char * a){
		/* Simple hashing function
		 * For each letter, do
		 * 	sum += ascii(a[i]) + prime offset
		 *
		 */
		int i;
		int len = strlen(a);
		int sum = 0;
		for(i=0;i<len;i++){
				sum += (int) a[i] + OFFSET;
		}
		return sum%CAP;
}

int find_in_hash(VariableDec ** Found, SymTable S, char * varname){
		int hashkey = createhash(varname);
		SymTable *tmp = &S;
		if(isdigit(varname[0])){
			int flag = 0;
			int j = 1;
			for(j=0;j<strlen(varname);j++){
					if(isdigit(varname[j])==0){
							flag = 1;
							break;	
					}
			}
			if(flag){
				/* Unknown symbol */
				return 104;
			}else{
				/* Allocate a tmp variable */
				*Found = (VariableDec *) malloc (sizeof(VariableDec));
				strcpy((*Found)->varname,"tmp");
				(*Found)->type = 'i';
				(*Found)->value = (char *) malloc (sizeof(int));
				*(*Found)->value = atoi(varname); 
				return 102;
			}
		}/*else if(varname[0]=='"' && varname[strlen(varname)-1]=='"'){
		}else if (varname[0]!='"' || varname[strlen(varname)-1]!='"'){
			return 104;
		}*/
		else{
			while(tmp != NULL){
				VariableDec * vars =  tmp->Vars[hashkey];
				while(vars!=NULL){
					if(strcmp(vars->varname,varname) == 0){
						*Found = vars;		
						return 0;
					}else{
						vars = vars->prev;
					}
				}
				tmp = tmp->prev;
			}
		/* If it didn't return in the loop, then things went wrong */
			return 101;
		}
		/* Something went wrong */
		return 106;
}
