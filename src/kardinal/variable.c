/* kardinal/variable.c
 * Omkar H. Ramachandran
 * omkar.ramachandran@colorado.edu
 *
 * Main script parser/logic interface of the game. Do not edit this file unless 
 * absolutely necessary
 * 
 *
 * This project is under the GNU General GPL version 3.0 license. For more 
 * information about the license, refer the LICENCE file in the root directory 
 * or go online to <http://www.gnu.org/licenses>
 *  
 * Any redistribution of this code must contain this header in its entirety
 */

#include "kardinal.h"

int Free_var(SymTable *S){
	int i;
	for(i=0;i<CAP;i++){
		VariableDec * var = S->Vars[i];
		while(var != NULL){
			VariableDec *tmp = var;
			var = var->prev;
			free(tmp->value);
			free(tmp);
		}
	}
	return 0;
}

int Free_tmp_vars(SymTable *S,int num_temp_variables){
	int i;
	for(i=0;i<num_temp_variables;i++){
		char resname[12];
		snprintf(resname,12,"__tmp%d",i);
		int hashkey = createhash(resname);
		VariableDec * var = S->Vars[hashkey];
		VariableDec * old = NULL;
		while(var != NULL){
			if(strcmp(var->varname,resname) != 0){
			/* Delete this link in the list */
				old = var;
				var = var->prev;
				continue;
			}
			
			if(old){
				old->prev = var->prev;
			}else{
				S->Vars[hashkey] = var->prev;
			}
			free(var->value);
			free(var);
			break;
		}
	}
	return 0;
}

void print_variable_stack(SymTable S){
 	int i;
	for(i=0;i<CAP;i++){
		if(S.Vars[i]!=NULL){	
			VariableDec * tmp = S.Vars[i];
 			while(tmp != NULL){
				printf("%d:%s:%c:%d\n",i,tmp->varname,tmp->type,*((int *)tmp->value));
				tmp = tmp->prev;
			}
		}
	}
}

/* This is STRICTLY a work in progress function! The return type is Input * 
 *  because I didn't want to pass a pointer by reference (and thus work with
 *  a pointer to a pointer which is also a struct).
 *  If ANYONE has a better implementation, please implement it and send a 
 *  pull request to VariableSupportOHR
 */
int setvar(SymTable * S, Input ** args, int debug){
		VariableDec *var = (VariableDec*)malloc(sizeof(VariableDec));
		int is_var=0;
		
		if(var == NULL){
				(debug==1) ? fprintf(stderr,"Error : Malloc returned NULL. Is there any memory left?\n") : 0;
				return -1;
		}
		(debug==1) ? fprintf(stderr,"Debug : New Variable Allocated\n") : 0;

		if((*args)->name[0]=='"'){
				/* If the first character is a ", then the type is string */		
		//		fprintf(stderr, "Debug: Variable is a string\n");
				var->type='s';
		}else if(isdigit((*args)->name[0])){
			int flag = 0;
			int j = 1;
			for(j=0;j<strlen((*args)->name);j++){
					if(isdigit((*args)->name[j])==0){
							flag = 1;
							break;	
					}
			}
			if(flag){
				// Title name. Alphanumeric
				var->type = 't';
			}else{
				var->type = 'i';
			}
		}else{
			/* Argument is a variablename */
			VariableDec * tmp;
			int res = find_in_hash(&tmp,*S,(*args)->name);
			if(res != 0){
			// Something went wrong. Likely, the variable hasn't
			// been allocated yet	
				free(var);
				fprintf(stdout,"Error in setvar: Unknown symbol %s",(*args)->name);
				return res;
			}
			else{
				is_var = 1;	
				if(tmp->type == 'c'){
						var->value = (char *) malloc(sizeof(tmp->value));
						strcpy((char *)var->value, (char *)tmp->value); 
				}else if(tmp->type == 'i'){
						var->value = (int *) malloc(sizeof(tmp->value));
						*((int *)var->value)= *(int *)tmp->value; 
				}
				var->type = tmp->type;
			}
		}
		(debug==1) ? fprintf(stderr,"Debug : Type = %c\n",var->type) : 0;

		//Extract Args here
		if(!is_var){
			if(var->type == 'i'){
				var->value=(int *)malloc(sizeof(int));
				//		var->size=sizeof(char)*(strlen((*args)->name)+1);
			}else if(var->type == 's'){
				var->value=(char *)malloc(sizeof(char)*(strlen((*args)->name)-2));
			}else{
				free(var);
				(debug==1) ? fprintf(stderr,"Type not mentioned. Check documentation for syntax\n") : 0;
				return -2;
				/*
				 *  NearlyHeadless,
				 *  Someone needs to do an errorcheck on the default. Ideally,
				 *  we just shouldn't allow the type variable to be empty
				 */
			}	// Compatible only for single float values
			if(var->type == 'i'){
				int buffer = atoi((*args)->name);
				*((int *)var->value) = buffer; 	
				(debug==1) ? fprintf(stderr,"Debug: Assigned %d successfully\n",*((int *)var->value)) : 0;
			}else if(var->type == 's'){
				int j,flag =0;
				char * array = (char *) var->value;
				for(j=1; j<strlen((*args)->name)-1; j++){
						if((*args)->name[j]=='\\'){
								array[j-1-flag]='\n';
								j++;
								flag++;
						}else
								array[j-1-flag]=(*args)->name[j];
				}
				array[j-1-flag] = '\0';
				(debug==1) ? fprintf(stderr,"Debug: Assigned %s successfully\n",(char *)var->value) : 0;
			}
		}
		(*args) = (*args)->prev;

		strcpy(var->varname,(*args)->name);
		var->prev = NULL;

		VariableDec *tmp_var = NULL;
		int res = find_in_hash(&tmp_var,*S,var->varname);

		if(res){
			int hashkey = createhash(var->varname);
			if(S->Vars[hashkey] == NULL){	
				S->Vars[hashkey]=var;
			}else{
				VariableDec * tmp = S->Vars[hashkey];
				while(tmp->prev != NULL){
						tmp = tmp->prev;
				}
				tmp->prev = var;
			}
		}else{
			/* Variable already in SymTable */
			free(tmp_var->value);
			if(var->type == 's'){
				tmp_var->value = (char *) malloc (sizeof(*var->value));
				strcpy((char *)tmp_var->value,(char *)var->value);
			}else{
				tmp_var->value = (int *) malloc (sizeof(*var->value));
				*((int *)tmp_var->value) = *((int *)var->value);
			}
			tmp_var->type = var->type;	
			free(var);
		}
			
		return 0;
}

int createhash(char * a){
		/* Simple hashing function
		 * For each letter, do
		 * 	sum += ascii(a[i]) + prime offset
		 *
		 */
		int i;
		int len = strlen(a);
		int sum = 0;
		for(i=0;i<len;i++){
				sum += (int) a[i] + OFFSET;
		}
		return sum%CAP;
}

int find_in_hash(VariableDec ** Found, SymTable S, char * varname){
		int hashkey = createhash(varname);
		SymTable *tmp = NULL;
		if(isdigit(varname[0])){
			int flag = 0;
			int j = 0;
			for(j=0;j<strlen(varname);j++){
					if(isdigit(varname[j])==0){
							flag = 1;
							break;	
					}
			}
			if(flag){
				/* Unknown symbol */
				return 104;
			}else{
				/* Allocate a tmp variable */
				*Found = (VariableDec *) malloc (sizeof(VariableDec));
				strcpy((*Found)->varname,"tmp");
				(*Found)->type = 'i';
				(*Found)->value = (char *) malloc (sizeof(int));
				*((int *) (*Found)->value) = atoi(varname); 
				(*Found)->prev = NULL;
				return 102;
			}
		}/*else if(varname[0]=='"' && varname[strlen(varname)-1]=='"'){
		}else if (varname[0]!='"' || varname[strlen(varname)-1]!='"'){
			return 104;
		}*/
		else{
			tmp = &S;
			while(tmp != NULL){
				VariableDec * vars =  tmp->Vars[hashkey];
				while(vars!=NULL){
					if(strcmp(vars->varname,varname) == 0){
						*Found = vars;		
						return 0;
					}else{
						vars = vars->prev;
					}
				}
				tmp = tmp->prev;
			}
		/* If it didn't return in the loop, then things went wrong */
			return 101;
		}
}
