/* kardinal/parse.c
*  Omkar H. Ramachandran
*  omkar.ramachandran@colorado.edu
*
*  Main script parser/logic interface of the game. Do not edit this file unless 
*  absolutely necessary
* 
*
*  This project is under the GNU General GPL version 3.0 license. For more 
*  information about the license, refer the LICENCE file in the root directory 
*  or go online to <http://www.gnu.org/licenses>
*  
*  Any redistribution of this code must contain this header in its entirety
*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "kardinal.h"

#define MAXBUF 100

void header(){
	printf("Debug : ");
}

int freeform_new(Input **In, Input cur, int pos){
	// Creates a new node in the freeform stack

	Input * new = (Input *) malloc (sizeof(Input));
	new->lvl = cur.lvl;
	new->type = cur.type;
	strcpy(new->name,cur.name);
	new->prev = *In;
	new->pos = pos;
	*In = new;
//	printf("Debug : %d : %s : %d : %d\n",cur.lvl,cur.name,cur.type,pos);	
	return 0;
}

Input * build(Input * In, char *in){
	// Declarations
	char buf[MAXBUF];
	int i = 0;
	int index = 0;
	int lvl = 0;
	int maxlvl = 0;
	char ch = in[i];
		
	// Remove preceding spaces
	while(ch == ' '){
		i++;
		ch = in[i];
	}
	printf("Debug : Removed spaces\n");	
	int flag = 0;
	while(i<strlen(in)){
		ch = in[i];
//		Input * cmd;
		if(ch == '('){
			buf[index] = '\0';
			if(flag==0){
				strcpy(In->name,buf);
				In->type = 1;
				In->prev = NULL;
				In->lvl = lvl;
			}else{
				Input * new = (Input *) malloc (sizeof(Input));
				strcpy(new->name,buf);
				new->type = 1;				
				new->prev = In;
				new->lvl = lvl;
				In = new;
			}
			flag ++;
			index = 0;
			lvl+=1;
		}else if(ch == ',' || ch == ')' && index!=0){
			buf[index] = '\0';
		//	printf("buf : %s\n",buf);
			Input * new = (Input *) malloc (sizeof(Input));
			strcpy(new->name,buf);
			new->type = 0;
			new->lvl = lvl;
			maxlvl = (lvl>maxlvl)?lvl:maxlvl;
			new->prev = In;
	//		new->parent = In;
			In = new;
			flag++;
			index = 0;
			if(ch == ')' && i != strlen(in)-1){
	// Skip the next 'comma' Ex : var(var2(arg1,arg2),arg3) Skip the comma after arg2) and go straight to arg3
				lvl -= 1;
				i++;
				ch = in[i];
				while(ch == ' ' || ch == ','){
					i++;
					ch = in[i];
				}
				continue;
			} 
		}else if(ch != ' ' && index < MAXBUF && ch!=')'){
			buf[index] = ch;
			index++;
		//	printf("buf : %s\n",buf);
		}
		i++;
	}
//	printf("%s : %d : %d : %s\n\n\n",In->name,In->lvl,In->type,In->prev->name);
	return In;	
}

void Free(Input * In){
	while(In != NULL){
		Input * tmp = In;
		In = In->prev;
		free(tmp);
	}
	free(In);
}

int find_maxlvl(Input In){
	Input *tmp = &In;
	int maxlvl = 0;	
	while(tmp!=NULL){
		maxlvl = (tmp->lvl>maxlvl)?tmp->lvl:maxlvl;	
		tmp = tmp->prev;
	}
	return maxlvl;
}

void print(Input In){
	Input *tmp = &In;
//	printf("%d\n",strcmp(In.name,"def\0"));
	int flag = 0;
//	printf("i : str : t : l\n");
//	printf("Debug : tmp = %p\n",tmp);
	while(tmp != NULL){
		printf("Debug : %d : %s : %d : %d\n",flag,tmp->name,tmp->type,tmp->lvl);
		tmp = tmp->prev;
		flag++;
	}
}

Input * selective_free(Input *In, int lvl_limit){
	Input *cur = In;
	Input *old = NULL;
	while(cur!=NULL){
		if(cur->lvl == lvl_limit){
			Input * tmp = cur;
			cur = cur->prev;
			if(old!=NULL)
				old->prev = cur;
			else
				In = cur;
			free(tmp);
		}else{
			Input *tmp = cur;
			cur = cur->prev;
			old = tmp;
		}
	}
	return In;
}

int write(Input *In1, Input *In2){
	strcpy(In1->name,In2->name);
	In1->type = In2->type;
	In1->lvl = In2->lvl;
	In1->prev = In2->prev;
}

void sequential_print(Input *In, char *name){
	int i=0;
	Input *tmp = In;
	do{
		printf("Debug : %s[%d].name = %s\n",name,i,tmp->name);
		tmp = tmp->prev;
		i++;
	}while(tmp!=NULL);
}

Input * parse(Input * In){
	int i,j;
//	int size_argsold = 0;
	int maxlvl = find_maxlvl(*In);
//	printf("Debug : maxlvl = %d\n",maxlvl);	
//	int curlvl = In->lvl;
	int pos = 0;	
	Input *argsold = NULL;
//	Input *args = NULL;
	Input *old = In;
	Input *cur = In->prev;
	int curlvl = old->lvl; 
// I'm shifting the defn of curlvl here to make things a little clearer.

	printf("Debug : Entered parse\n");

	while(cur!=NULL){
		if(cur->lvl > curlvl){
/* If stmt 1 in the gameplan. If cur->lvl > curlvl, then we are inside another
* command. Something like ..cur),old.. As a result, we need to add old to 
* argsold and we should be done.
*/
			printf("Debug : Entered if stmt 1\n");
			freeform_new(&argsold,*old,pos);
			printf("Debug : Survived freeform_new()\n");
//			size_argsold++;
//			write(&argsold[size_argsold],old);
			print(*argsold);
		//	old = cur;
			pos++;
			curlvl = cur->lvl;
		}else if(cur->lvl < curlvl){
			int size_args = 0;
			printf("Debug : Entered if stmt 2\n");
			Input *tmp = In;
			Input *args=NULL;
			while(tmp->prev!=NULL){
				if(tmp->lvl == curlvl){
					freeform_new(&args,*tmp,size_args);
					size_args+=1;
			//		print(*args);
				//	char junk;
				//	scanf("%c",&junk);
				}
				tmp = tmp->prev;
//				printf("Debug : tmp --> tmp->prev\n");
			}

			printf("Debug : Survived the args loop\n");
			argsold = selective_free(argsold,curlvl);
		//	printf("Debug : tmp = %p\n",argsold);	
		//	print(*argsold);
/* Note : Author : OHR
*  For some reason, passing a null pointer to a function just leads straight to
*  a seg fault - even though I'm not using it. Anyone know why?
*/
			printf("Debug : Survived the selective_free\n");
			evaluate(cur,args,1);
			Free(args);
			curlvl = cur->lvl;
		}else{
			printf("Debug : Entered if stmt 3\n");
//			argsold = (Input *) realloc (argsold,(size_argsold+2)*sizeof(Input));
			printf("Debug : Survived Realloc if stmt 3\n");
			freeform_new(&argsold,*old,pos);
			printf("Debug : Survived Realloc if stmt 3\n");
			pos++;
			print(*argsold);
//			sequential_print(argsold,size_argsold,"argsold");
//			size_argsold+=1;
			curlvl = cur->lvl;
		}
//		sequential_print(argsold,size_argsold);
		old = cur;
		cur = cur->prev;	
	}
	Free(argsold);
	printf("Debug : Survived the core loop!\n");
//	In = selective_free(In,maxlvl);
//	Input *old = 
//	Input *tmp = In;
//	Input *argsold;
//	Input *args = (Input *) malloc (sizeof(Input));	
//	int curlvl = In->lvl;
//	int cmd_exec = 0;
//	free(args);
	return In;	
}
