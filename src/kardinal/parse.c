/* kardinal/parse.c
*  Omkar H. Ramachandran
*  omkar.ramachandran@colorado.edu
*
*  Main script parser/logic interface of the game. Do not edit this file unless 
*  absolutely necessary
* 
*
*  This project is under the GNU General GPL version 3.0 license. For more 
*  information about the license, refer the LICENCE file in the root directory 
*  or go online to <http://www.gnu.org/licenses>
*  
*  Any redistribution of this code must contain this header in its entirety
*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "kardinal.h"

#define MAXBUF 100

void header(){
	printf("Debug : ");
}

int freeform_new(Input **In, Input cur, int pos){
	// Creates a new node in the freeform stack

	Input * new = (Input *) malloc (sizeof(Input));
	new->lvl = cur.lvl;
	new->type = cur.type;
	strcpy(new->name,cur.name);
	new->prev = *In;
	new->pos = pos;
	*In = new;
	
	return 0;
}

Input * build(Input * In, char *in){
	// Declarations
	char buf[MAXBUF];
	int i = 0;
	int index = 0;
	int lvl = 0;
	int maxlvl = 0;
	char ch = in[i];
		
	// Remove preceding spaces
	while(ch == ' '){
		i++;
		ch = in[i];
	}
	printf("Debug : Removed spaces\n");	
	int flag = 0;
	while(i<strlen(in)){
		ch = in[i];
//		Input * cmd;
		if(ch == '('){
			buf[index] = '\0';
			if(flag==0){
				strcpy(In->name,buf);
				In->type = 1;
				In->prev = NULL;
				In->lvl = lvl;
			}else{
				Input * new = (Input *) malloc (sizeof(Input));
				strcpy(new->name,buf);
				new->type = 1;				
				new->prev = In;
				new->lvl = lvl;
				In = new;
			}
			flag ++;
			index = 0;
			lvl+=1;
		}else if(ch == ',' || ch == ')' && index!=0){
			buf[index] = '\0';
		//	printf("buf : %s\n",buf);
			Input * new = (Input *) malloc (sizeof(Input));
			strcpy(new->name,buf);
			new->type = 0;
			new->lvl = lvl;
			maxlvl = (lvl>maxlvl)?lvl:maxlvl;
			new->prev = In;
	//		new->parent = In;
			In = new;
			flag++;
			index = 0;
			if(ch == ')' && i != strlen(in)-1){
	// Skip the next 'comma' Ex : var(var2(arg1,arg2),arg3) Skip the comma after arg2) and go straight to arg3
				lvl -= 1;
				i++;
				ch = in[i];
				while(ch == ' ' || ch == ','){
					i++;
					ch = in[i];
				}
				continue;
			} 
		}else if(ch != ' ' && index < MAXBUF && ch!=')'){
			buf[index] = ch;
			index++;
		//	printf("buf : %s\n",buf);
		}
		i++;
	}
//	printf("%s : %d : %d : %s\n\n\n",In->name,In->lvl,In->type,In->prev->name);
	return In;	
}

void Free(Input * In){
	while(In->prev != NULL){
		Input * tmp = In;
		In = In->prev;
		free(tmp);
	}
	free(In);
}

int find_maxlvl(Input In){
	Input *tmp = &In;
	int maxlvl = 0;	
	while(tmp!=NULL){
		maxlvl = (tmp->lvl>maxlvl)?tmp->lvl:maxlvl;	
		tmp = tmp->prev;
	}
	return maxlvl;
}

void print(Input In){
	Input *tmp = &In;
//	printf("%d\n",strcmp(In.name,"def\0"));
	int flag = 0;
//	printf("i : str : t : l\n");
	while(tmp != NULL){
		printf("Debug : %d : %s : %d : %d\n",flag,tmp->name,tmp->type,tmp->lvl);
		tmp = tmp->prev;
		flag++;
	}
}

Input * sel_free(Input *In, int lvl_limit){
	Input *cur = In;
	Input *old = NULL;
	while(cur!=NULL){
		if(cur->lvl == lvl_limit){
			Input * tmp = cur;
			cur = cur->prev;
			if(old!=NULL)
				old->prev = cur;
			else
				In = cur;
			free(tmp);
		}else{
			Input *tmp = cur;
			cur = cur->prev;
			old = tmp;
		}
	}
	return In;
}

int write(Input *In1, Input *In2){
	strcpy(In1->name,In2->name);
	In1->type = In2->type;
	In1->lvl = In2->lvl;
	In1->prev = In2->prev;
}

void sequential_print(Input *In, char *name){
	int i=0;
	Input *tmp = In;
	do{
		printf("Debug : %s[%d].name = %s\n",name,i,tmp->name);
		tmp = tmp->prev;
		i++;
	}while(tmp->prev!=NULL);
}

Input * selective_free(Input *In, int lev_limit, int *size_args){
	int i,j;
	int size = *size_args;
	int flag=0;
//	sequential_print(In,size);
	for(i=0;i<size;i++){
		if(In[i].lvl==lev_limit){
			// Delete element
			for(j=i+1;j<size;j++){
				write(&In[j-1],&In[j]);
			}	
			flag++;
		}
	}
	printf("Debug : Flag : %d\nDebug : size_args : %d\n",flag,size);
	Input *tmp = (Input *) malloc ((size-flag)*sizeof(Input));
	for(i=0;i<size-flag;i++){
		write(&tmp[i],&In[i]);
	}
	
	free(In);
	*size_args = size-flag; 
	return tmp;
}

Input * evaluate(Input * In, Input * args, int size_args){
// Dummy evaluate function. Must be updated in the next few iterations. 
// Perhaps a starting project for NearlyHeadless?
	strcpy(In->name,"Result");
	In->type = 0;
}

Input * parse(Input * In){
	int i,j;
//	int size_argsold = 0;
	int maxlvl = find_maxlvl(*In);
//	printf("Debug : maxlvl = %d\n",maxlvl);	
//	int curlvl = In->lvl;
	int pos = 0;	
	Input *argsold = NULL;
	Input *args = NULL;
	Input *old = In;
	Input *cur = In->prev;
	int curlvl = old->lvl; 
// I'm shifting the defn of curlvl here to make things a little clearer.

	printf("Debug : Entered parse\n");

	while(cur!=NULL){
		if(cur->lvl > curlvl){
/* If stmt 1 in the gameplan. If cur->lvl > curlvl, then we are inside another
* command. Something like ..cur),old.. As a result, we need to add old to 
* argsold and we should be done.
*/
			printf("Debug : Entered if stmt 1\n");
			freeform_new(&argsold,*old,pos);
			printf("Debug : Survived freeform_new()\n");
//			size_argsold++;
//			write(&argsold[size_argsold],old);
			print(*argsold);
		//	old = cur;
			pos++;
			curlvl = cur->lvl;
		}else if(cur->lvl < curlvl){
			int size_args = 1;
			printf("Debug : Entered if stmt 2\n");
/*			for(j=0;j<size_argsold;j++){
				if(argsold[i].lvl == cur->lvl+1){
					args = (Input *) realloc (args,sizeof(Input)*(size_args+1));
					write(&args[size_args],&argsold[i]);
					size_args+=1;
				}
			}
*/
			printf("Debug : Survived the args loop\n");
//			argsold = selective_free(argsold,cur->lvl+1,&size_argsold);
//			sequential_print(argsold,size_argsold,"argsold");
			printf("Debug : Survived the selective_free\n");
			cur = evaluate(cur,argsold,1);
			curlvl = cur->lvl;
		}else{
			printf("Debug : Entered if stmt 3\n");
//			argsold = (Input *) realloc (argsold,(size_argsold+2)*sizeof(Input));
			printf("Debug : Survived Realloc if stmt 3\n");
			freeform_new(&argsold,*old,pos);
			printf("Debug : Survived Realloc if stmt 3\n");
			pos++;
			print(*argsold);
//			sequential_print(argsold,size_argsold,"argsold");
//			size_argsold+=1;
			curlvl = cur->lvl;
		}
//		sequential_print(argsold,size_argsold);
		old = cur;
		cur = cur->prev;	
	}
	Free(argsold);
	printf("Debug : Survived the core loop!\n");
//	In = selective_free(In,maxlvl);
//	Input *old = 
//	Input *tmp = In;
//	Input *argsold;
//	Input *args = (Input *) malloc (sizeof(Input));	
//	int curlvl = In->lvl;
//	int cmd_exec = 0;
//	free(args);
	return In;	
}
